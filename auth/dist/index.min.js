"use strict";var h=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)};var u=(n,e,t)=>(h(n,e,"read from private field"),t?t.call(n):e.get(n)),r=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},p=(n,e,t,s)=>(h(n,e,"write to private field"),s?s.call(n,t):e.set(n,t),t);var i=(n,e,t)=>(h(n,e,"access private method"),t);var c,a,o,f,l,m,g,k;import{SignJWT as I,importPKCS8 as _}from"jose";import{createHash as b,randomBytes as y}from"node:crypto";class D{constructor(e,t){r(this,o);r(this,l);r(this,g);r(this,c,void 0);r(this,a,void 0);p(this,c,e),p(this,a,t)}async createToken(e,t){const s=await _(u(this,a),"EdDSA");let d={token:await new I({...e}).setProtectedHeader({alg:"EdDSA"}).setExpirationTime(t?.duration||"2h").sign(s)};if(t?.pkce){let T=i(this,g,k).call(this);d={...d,...T}}return d}}c=new WeakMap,a=new WeakMap,o=new WeakSet,f=function(e){return e.toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")},l=new WeakSet,m=function(e){return b("sha256").update(e).digest()},g=new WeakSet,k=function(){let e=i(this,o,f).call(this,y(32));return{code_challenge:i(this,o,f).call(this,i(this,l,m).call(this,e)),code_verifier:e}};export default D;export{};
