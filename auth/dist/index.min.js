"use strict";var h=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)};var m=(n,e,t)=>(h(n,e,"read from private field"),t?t.call(n):e.get(n)),r=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},p=(n,e,t,s)=>(h(n,e,"write to private field"),s?s.call(n,t):e.set(n,t),t);var a=(n,e,t)=>(h(n,e,"access private method"),t);var c,i,o,f,d,u,l,k;import{SignJWT as y,importPKCS8 as I}from"jose";import{createHash as _,randomBytes as v}from"node:crypto";class w{constructor(e,t){r(this,o);r(this,d);r(this,l);r(this,c,void 0);r(this,i,void 0);p(this,c,e),p(this,i,t)}async createToken(e,t){const s=await I(m(this,i),"EdDSA");let g={token:await new y({...e}).setProtectedHeader({alg:"EdDSA"}).setExpirationTime(t?.duration||"2h").sign(s)};if(t?.pkce){let T=a(this,l,k).call(this);g={...g,...T}}return g}}c=new WeakMap,i=new WeakMap,o=new WeakSet,f=function(e){return e.toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")},d=new WeakSet,u=function(e){return _("sha256").update(e).digest()},l=new WeakSet,k=function(){let e=a(this,o,f).call(this,v(32));return{code_challenge:a(this,o,f).call(this,a(this,d,u).call(this,e)),code_verifier:e}};export default w;export{};
