var c=class{constructor(){this.callbacks={}}on(e,t){this.callbacks[e]=t}dispatch(e,t){let r=this.callbacks[e];r&&r(t)}off(e){this.callbacks[e]&&delete this.callbacks[e]}clearAllEvents(){this.callbacks={}}cleaEvents(e){e.forEach(t=>{this.off(t)})}};var h=(u,e)=>Object.prototype.toString.call(u)==="[object "+e+"]",d=class{#t;#e;constructor(e){this.#t=0,this.#e=new DataView(e)}getU8(){let e=this.#e.getUint8(this.#t);return this.#t+=1,e}getFixedSeq(e){let t=this.#e.buffer.slice(this.#t,this.#t+e);return this.#t+=e,t}getSeq(){let e=this.getU32();return this.getFixedSeq(e)}getU32(){let e=this.#e.getUint32(this.#t,!0);return this.#t+=4,e}geti64(){let e=this.#e.getBigInt64(this.#t,!0);return this.#t+=8,e}getString(){let e=this.getSeq();return new TextDecoder().decode(e)}getRest(){return this.#e.buffer.slice(this.#t)}asString(e){return new TextDecoder().decode(e)}};var l=class{#t;#e;#r;constructor(e){this.userMap=new Map,this.tracks=new Map,this.#t=new Map,this.#e=new Map,this.#r=e}addTracks(e){this.tracks.set(e.id,e);let t=this.#t.get(e.id);if(!t){this.#e.set(e.id,e);return}let r=this.userMap.get(t.userId),n={id:e.id,name:t.name,muted:t.muted};r?r.push(n):this.userMap.set(t.userId,[n]),this.#t.delete(e.id),this.trackAdded(t.userId,e.id)}addUserTracks(e,t){t.forEach(r=>{if(!this.#e.get(r.id)){this.#t.set(r.id,{userId:e,name:r.name,muted:r.muted});return}let s=this.userMap.get(e),i={name:r.name,id:r.id,muted:r.muted};s?s.push(i):this.userMap.set(e,[i]),this.#e.delete(r.id),this.trackAdded(e,r.id)})}updateTracks(e,t){let r=this.userMap.get(e);if(!r)return;if(t.action==="mute"){for(let s of r){if(!t.names.includes(s.name))continue;let i=t.val;s.muted=i;let a=this.tracks.get(s.id);a&&(a.enabled=!i);let o={userId:e,trackName:s.name,userRef:this.getUserRef(e),value:i};this.#r.dispatch("track:mute",o)}return}if(t.action==="mute-r"){let s=t,i=this.userMap.get(s.userId);if(!i)return;i.forEach(a=>{let o=this.tracks.get(a.id);o&&(o.enabled=!s.state);let f={userId:s.userId,trackName:a.name,userRef:this.getUserRef(e),value:s.state,mutedBy:s.mutedBy,muteReason:s.reason};this.#r.dispatch("track:mute",f)});return}let n=r.filter(s=>t.names.includes(s.name)?(this.tracks.get(s.id)?.stop(),this.tracks.delete(s.id),!0):!1);this.userMap.set(e,n);for(let s of t.names){let i={userId:e,trackName:s,userRef:this.getUserRef(e)};this.#r.dispatch("track:del",i)}}getUserRef(e){let t={};return this.userMap.get(e)?.forEach(n=>{let s=this.tracks.get(n.id);s&&(t[n.name]={muted:n.muted,track:s})}),t}trackAdded(e,t){let r={},n="",s=this.userMap.get(e);if(!s)return;s.forEach(a=>{a.id==t&&(n=a.name);let o=this.tracks.get(a.id);o&&(r[a.name]={muted:a.muted,track:o})});let i={userId:e,track:this.tracks.get(t),trackName:n,userRef:r};this.#r.dispatch("track:add",i)}removeUser(e){this.userMap.delete(e)}};var g=200,p=201;var m=class{#t;#e;#r;#n;#a=!1;#u=!0;constructor(e){this.channel="",this.tracks={},this.status="disconnected",this.#t=e,this.#e=new RTCPeerConnection({bundlePolicy:"balanced"}),this.#c(),this.#n=new c,this.#r=new l(this.#n),this.#t.subscribe(p,t=>{this.#d(t)}),this.#t.subscribe(g,t=>{if(h(t,"ArrayBuffer")){try{let r=new d(t),n=r.getString(),s=r.getString(),i=JSON.parse(r.getString());i.tracks?this.#r.addUserTracks(s,i.tracks):this.#r.updateTracks(s,i)}catch(r){console.error("invalid call data in",r)}return}if(t.type==="event"){if(console.log("channel|call ev: ",t),t.event==="user:left")this.#r.removeUser(t.userId),this.#n.dispatch("user:left",{userId:t.userId});else if(t.event==="cnl:delete")this.#i(),this.#n.dispatch("cnl:delete",{reason:t.reason});else if(t.event==="user:del"){let r=!1;for(let n of t.users)if(n.id===this.#t.userId){r=!0,this.#i();break}this.#n.dispatch("user:del",{senderId:t.userId,users:t.users.map(n=>n.id),meIncluded:r})}else if(t.event==="user:mod"){let r=!1;for(let n of t.users)if(n.id===this.#t.userId){r=!0,this.#i();break}this.#n.dispatch("user:mod",{senderId:t.userId,users:t.users,meIncluded:r})}}})}#c(){this.#e.oniceconnectionstatechange=()=>{console.log("call state: ",this.#e.iceConnectionState)},this.#e.onnegotiationneeded=async()=>await this.#h(),this.#e.ontrack=e=>{let t=e.track;this.#r.addTracks(t)}}async#d(e){console.log("got signal");try{let t=e.type==="offer"&&(this.#a||this.#e.signalingState!=="stable");if(!this.#u&&t){console.log("impolite ignorance waiting ready to re_consume");return}await this.#e.setRemoteDescription(e),e.type==="offer"&&(await this.#e.setLocalDescription(),await this.#l(this.#e.localDescription))}catch(t){console.error("new signal error",t)}}async#h(){console.log("negotiation needed");try{this.#a=!0,await this.#e.setLocalDescription(),await this.#l(this.#e.localDescription)}catch(e){console.error("negotiation error",e)}finally{this.#a=!1}}async#s(e,t,r){return this.#t.send(7,e,{channel:this.channel,data:JSON.stringify(t)},r)}async#l(e){this.#s(4,e,!1)}#i(){this.#e.close(),Object.entries(this.tracks).forEach(([e,t])=>{t.stop()}),this.tracks={},this.#r=new l(this.#n),this.#e=new RTCPeerConnection({bundlePolicy:"balanced"}),this.#c()}async#o(e,t){await this.#s(8,{action:e,users:t})}static pluginId(){return"calls"}on(e,t){this.#n.on(e,t)}async addTracks(e){console.log("adding tracks ",e),this.tracks={...this.tracks,...e},Object.entries(e).forEach(([t,r])=>{this.#e.addTransceiver(r,{direction:"sendonly"}),this.#s(3,{tracks:[{id:r.id,kind:r.kind,name:t,muted:!1}]})})}async removeTracks(e){let t=Array.isArray(e)?e:[e],r=t.map(s=>this.tracks?.[s].id).filter(Boolean),n=this.#e.getTransceivers().filter(s=>s.direction==="sendonly");for(let s of r)for(let i of n)i.sender.track?.id===s&&i.sender.track.stop();this.#s(5,{action:"del",names:t},!1);for(let s of t)delete this.tracks[s]}async muteTracks(e,t){let r=Array.isArray(e)?e:[e];for(let n of r){let s=this.tracks[n];s&&(s.enabled=!t)}this.#s(5,{action:"mute",val:t,names:r},!1)}async muteUser(e,t,r,n){this.#s(6,{state:r,kind:t,user_id:e,reason:n})}async create(e,t,r){this.channel=e;try{return await this.#s(0,r||{}),t&&await this.addTracks(t),{status:!0}}catch(n){throw n}}async join(e,t){this.channel=e;try{let r=await this.#s(1,{});for(let n of Object.entries(r)){let[s,i]=n;this.#r.addUserTracks(s,Object.values(i.tracks))}return t&&await this.addTracks(t),{status:!0}}catch(r){throw r}}async leave(){return await this.#s(2,{}),this.#i(),{status:!0}}async delete(e){return await this.#s(7,{reason:e}),this.#i(),{status:!0}}async addUsers(e){if(!e.length)return{status:!1};let t=e.map(r=>({id:r,mode:0}));return await this.#o("add",t),{status:!0}}async delUsers(e){if(!e.length)return{status:!1};let t=e.map(r=>({id:r,mode:0}));await this.#o("del",t);for(let r of e)this.#r.removeUser(r);return{status:!0}}async modUsers(e){return e.length?(await this.#o("mod",e),{status:!0}):{status:!1}}async getUsers(){let e=[],t=this.#r.userMap;for(let[r,n]of t){let s={},i=this.#r.getUserRef(r);s.tracks=i,s.mode=6,e.push(s)}return e}async configure(e){return await this.#s(9,e),{status:!0}}};export{m as default};
